"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OnChainZKPVerifier = void 0;
const ethers_1 = require("ethers");
const ZkpVerifier_json_1 = __importDefault(require("./abi/ZkpVerifier.json"));
const blockchain_1 = require("../../blockchain");
/**
 * OnChainZKPVerifier is a class that allows to interact with the OnChainZKPVerifier contract
 * and submitZKPResponse.
 *
 * @beta
 * @class OnChainZKPVerifier
 */
class OnChainZKPVerifier {
    /**
     *
     * Creates an instance of OnChainZKPVerifier.
     * @beta
     * @param {EthConnectionConfig[]} - array of ETH configs
     */
    constructor(_configs) {
        this._configs = _configs;
        /**
         * solidity identifier for function signature:
         * function submitZKPResponse(uint64 requestId, uint256[] calldata inputs,
         * uint256[2] calldata a, uint256[2][2] calldata b, uint256[2] calldata c) public
         */
        this._supportedMethodId = 'b68967e2';
    }
    /**
     * Submit ZKP Responses to OnChainZKPVerifier contract.
     * @beta
     * @param {Signer} ethSigner - tx signer
     * @param {txData} ContractInvokeTransactionData - transaction data
     * @param {ZeroKnowledgeProofResponse[]} zkProofResponses - zkProofResponses
     * @returns {Promise<Map<string, ZeroKnowledgeProofResponse>>} - map of transaction hash - ZeroKnowledgeProofResponse
     */
    async submitZKPResponse(ethSigner, txData, zkProofResponses) {
        const chainConfig = this._configs.find((i) => i.chainId == txData.chain_id);
        if (!chainConfig) {
            throw new Error(`config for chain id ${txData.chain_id} was not found`);
        }
        if (txData.method_id.replace('0x', '') !== this._supportedMethodId) {
            throw new Error(`submit doesn't implement requested method id. Only '0x${this._supportedMethodId}' is supported.`);
        }
        const provider = new ethers_1.JsonRpcProvider(chainConfig.url, chainConfig.chainId);
        const verifierContract = new ethers_1.Contract(txData.contract_address, ZkpVerifier_json_1.default, provider);
        ethSigner = ethSigner.connect(provider);
        const contract = verifierContract.connect(ethSigner);
        const response = new Map();
        for (const zkProof of zkProofResponses) {
            const requestID = zkProof.id;
            const inputs = zkProof.pub_signals;
            const payload = [
                requestID,
                inputs,
                zkProof.proof.pi_a.slice(0, 2),
                [
                    [zkProof.proof.pi_b[0][1], zkProof.proof.pi_b[0][0]],
                    [zkProof.proof.pi_b[1][1], zkProof.proof.pi_b[1][0]]
                ],
                zkProof.proof.pi_c.slice(0, 2)
            ];
            const feeData = await provider.getFeeData();
            const maxFeePerGas = chainConfig.maxFeePerGas
                ? BigInt(chainConfig.maxFeePerGas)
                : feeData.maxFeePerGas;
            const maxPriorityFeePerGas = chainConfig.maxPriorityFeePerGas
                ? BigInt(chainConfig.maxPriorityFeePerGas)
                : feeData.maxPriorityFeePerGas;
            const gasLimit = await contract.submitZKPResponse.estimateGas(...payload);
            const txData = await contract.submitZKPResponse.populateTransaction(...payload);
            const request = {
                to: txData.to,
                data: txData.data,
                gasLimit,
                maxFeePerGas,
                maxPriorityFeePerGas
            };
            const transactionService = new blockchain_1.TransactionService(provider);
            const { txnHash } = await transactionService.sendTransactionRequest(ethSigner, request);
            response.set(txnHash, zkProof);
        }
        return response;
    }
}
exports.OnChainZKPVerifier = OnChainZKPVerifier;
